{"version":3,"file":"index-30d94873.js","sources":["../../src/components/suid/Radios/index.tsx?raw"],"sourcesContent":["export default \"import { FormHandler } from '@interfaces';\\nimport {\\n  Component,\\n  createEffect,\\n  createSelector,\\n  createUniqueId,\\n  For,\\n  splitProps,\\n} from 'solid-js';\\nimport { Radio, RadioProps } from '@components/suid';\\nimport { createStore } from 'solid-js/store';\\nimport FormGroup from '@suid/material/FormGroup';\\nimport FormLabel from '@suid/material/FormLabel';\\nimport FormHelperText from '@suid/material/FormHelperText';\\n\\ntype SelectableOption = { value: string | number; label: string };\\n\\nexport interface RadiosProps {\\n  error?: boolean;\\n  errorMessage?: string;\\n  formHandler?: FormHandler;\\n  helperText?: string;\\n  id?: string;\\n  label?: string;\\n  options?: Array<SelectableOption>;\\n  name?: string;\\n  onChange?: RadioProps['onChange'];\\n  onBlur?: RadioProps['onBlur'];\\n  required?: boolean;\\n  value?: string | number;\\n  triggers?: string[];\\n}\\n\\nexport const Radios: Component<RadiosProps> = (props) => {\\n  /**\\n   * Props are divided in two groups:\\n   * - local: newer or extended/computed props.\\n   * - rest: remaining props from the interface.\\n   */\\n  const [local, rest] = splitProps(props, [\\n    'error',\\n    'errorMessage',\\n    'id',\\n    'onChange',\\n    'onBlur',\\n  ]);\\n\\n  /**\\n   * Derived/computed states from props.\\n   */\\n  const [store, setStore] = createStore({\\n    errorMessage: '',\\n    error: false,\\n    value: '',\\n    id: '',\\n  });\\n\\n  /**\\n   * Radio is checked\\n   */\\n  const checked = createSelector(() => store.value);\\n\\n  /**\\n   * Extended onChange event.\\n   */\\n  const onChange: RadiosProps['onChange'] = (event, checked) => {\\n    //Form handler prop sets and validate the value onChange.\\n    rest.formHandler?.setFieldValue?.(rest.name, event.currentTarget.value, {\\n      validateOn: [event.type],\\n    });\\n\\n    //onChange prop is preserved\\n    local?.onChange?.(event, checked);\\n  };\\n\\n  /**\\n   * Checkboxes onBlur event.\\n   */\\n  const onBlur: RadiosProps['onBlur'] = (event) => {\\n    //Form handler prop validate and touch the field.\\n    rest.formHandler?.validateField?.(rest.name, { validateOn: [event.type] });\\n    rest.formHandler?.touchField?.(rest.name);\\n\\n    //onBlur prop is preserved\\n    if (typeof local.onBlur === 'function') {\\n      local.onBlur(event);\\n    } else {\\n      local.onBlur?.[0](local.onBlur?.[1], event);\\n    }\\n  };\\n\\n  /**\\n   * Updates error message signal according to the given prop or form handler state.\\n   */\\n  createEffect(() => {\\n    setStore(\\n      'errorMessage',\\n      local.errorMessage || rest.formHandler?.getFieldError?.(rest.name) || ''\\n    );\\n  });\\n\\n  /**\\n   * Updates error flag signal according to the given prop or form handler state.\\n   */\\n  createEffect(() => {\\n    setStore(\\n      'error',\\n      local.error || rest.formHandler?.fieldHasError?.(rest.name) || false\\n    );\\n  });\\n\\n  /**\\n   * Initializes the form field unique id.\\n   */\\n  createEffect(() => {\\n    setStore('id', local.id || createUniqueId());\\n  });\\n\\n  /**\\n   * Controls component's value.\\n   */\\n  createEffect(() => {\\n    /**\\n     * If formHandler is defined, value is controlled by\\n     * the same component, if no, by the value prop.\\n     */\\n    setStore(\\n      'value',\\n      rest.formHandler\\n        ? rest.formHandler?.getFieldValue?.(rest.name)\\n        : rest.value\\n    );\\n  });\\n\\n  /**\\n   * Initializes the form field default value.\\n   */\\n  createEffect(() => {\\n    rest.formHandler?.setFieldDefaultValue?.(rest.name, rest.value);\\n  });\\n\\n  /**\\n   * Triggers dependant validations\\n   */\\n  createEffect(() => {\\n    rest?.formHandler?.setFieldTriggers?.(rest.name, rest.triggers);\\n  });\\n\\n  return (\\n    <FormGroup>\\n      {rest.label && (\\n        <FormLabel error={store.error} required={rest.required}>\\n          {rest.label}\\n        </FormLabel>\\n      )}\\n      <For each={rest.options}>\\n        {(option, i) => (\\n          <Radio\\n            id={`${store.id}-${i()}`}\\n            label={option.label}\\n            value={option.value}\\n            name={rest.name}\\n            onChange={onChange}\\n            onBlur={onBlur}\\n            error={store.error}\\n            checked={checked(option.value)}\\n          />\\n        )}\\n      </For>\\n      {rest.helperText && <FormHelperText>{rest.helperText}</FormHelperText>}\\n      {store.error && (\\n        <FormHelperText error={store.error}>\\n          {store.errorMessage}\\n        </FormHelperText>\\n      )}\\n    </FormGroup>\\n  );\\n};\\n\""],"names":["index"],"mappings":"AAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}