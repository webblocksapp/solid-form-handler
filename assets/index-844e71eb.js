const index = "import { FormHandler } from '@interfaces';\nimport {\n  Component,\n  createEffect,\n  createSelector,\n  createUniqueId,\n  For,\n  splitProps,\n} from 'solid-js';\nimport { Checkbox, CheckboxProps } from '@components/suid';\nimport { createStore } from 'solid-js/store';\nimport FormGroup from '@suid/material/FormGroup';\nimport FormLabel from '@suid/material/FormLabel';\nimport FormHelperText from '@suid/material/FormHelperText';\n\ntype SelectableOption = { value: string | number; label: string };\n\nexport interface CheckboxesProps {\n  error?: boolean;\n  errorMessage?: string;\n  formHandler?: FormHandler;\n  helperText?: string;\n  id?: string;\n  label?: string;\n  options?: Array<SelectableOption>;\n  name?: string;\n  onChange?: CheckboxProps['onChange'];\n  onBlur?: CheckboxProps['onBlur'];\n  required?: boolean;\n  value?: Array<string | number>;\n  triggers?: string[];\n}\n\nexport const Checkboxes: Component<CheckboxesProps> = (props) => {\n  /**\n   * Props are divided in two groups:\n   * - local: newer or extended/computed props.\n   * - rest: remaining props from the interface.\n   */\n  const [local, rest] = splitProps(props, [\n    'error',\n    'errorMessage',\n    'id',\n    'onChange',\n    'onBlur',\n  ]);\n\n  /**\n   * Derived/computed states from props.\n   */\n  const [store, setStore] = createStore({\n    errorMessage: '',\n    error: false,\n    value: [],\n    id: '',\n  });\n\n  /**\n   * Checkbox is checked\n   */\n  const checked = createSelector(\n    () => store.value,\n    (optionValue: string | number, storeValue) =>\n      storeValue?.some?.((item) => item == optionValue)\n  );\n\n  /**\n   * Checkboxes onChange logic.\n   */\n  const onChange: CheckboxesProps['onChange'] = (event, checked) => {\n    //If checked, value is pushed inside form handler.\n    if (event.currentTarget.checked) {\n      rest.formHandler?.setFieldValue?.(\n        rest.name,\n        [...store.value, event.currentTarget.value],\n        {\n          validateOn: [event.type],\n        }\n      );\n\n      //If unchecked, value is filtered from form handler.\n    } else {\n      rest.formHandler?.setFieldValue?.(\n        rest.name,\n        store.value?.filter?.((item: any) => event.currentTarget.value != item)\n      );\n    }\n\n    //onChange prop is preserved\n    local?.onChange?.(event, checked);\n  };\n\n  /**\n   * Checkboxes onBlur event.\n   */\n  const onBlur: CheckboxesProps['onBlur'] = (event) => {\n    //Form handler prop validate and touch the field.\n    rest.formHandler?.validateField?.(rest.name, { validateOn: [event.type] });\n    rest.formHandler?.touchField?.(rest.name);\n\n    //onBlur prop is preserved\n    if (typeof local.onBlur === 'function') {\n      local.onBlur(event);\n    } else {\n      local.onBlur?.[0](local.onBlur?.[1], event);\n    }\n  };\n\n  /**\n   * Updates error message signal according to the given prop or form handler state.\n   */\n  createEffect(() => {\n    setStore(\n      'errorMessage',\n      local.errorMessage || rest.formHandler?.getFieldError?.(rest.name) || ''\n    );\n  });\n\n  /**\n   * Updates error flag signal according to the given prop or form handler state.\n   */\n  createEffect(() => {\n    setStore(\n      'error',\n      local.error || rest.formHandler?.fieldHasError?.(rest.name) || false\n    );\n  });\n\n  /**\n   * Initializes the form field unique id.\n   */\n  createEffect(() => {\n    setStore('id', local.id || createUniqueId());\n  });\n\n  /**\n   * Controls component's value.\n   */\n  createEffect(() => {\n    /**\n     * If formHandler is defined, value is controlled by\n     * the same component, if no, by the value prop.\n     */\n    setStore(\n      'value',\n      rest.formHandler\n        ? rest.formHandler?.getFieldValue?.(rest.name)\n        : rest.value\n    );\n  });\n\n  /**\n   * Initializes the form field default value.\n   */\n  createEffect(() => {\n    rest.formHandler?.setFieldDefaultValue(rest.name, rest.value);\n  });\n\n  /**\n   * Triggers dependant validations\n   */\n  createEffect(() => {\n    rest?.formHandler?.setFieldTriggers?.(rest.name, rest.triggers);\n  });\n\n  return (\n    <FormGroup>\n      {rest.label && (\n        <FormLabel error={store.error} required={rest.required}>\n          {rest.label}\n        </FormLabel>\n      )}\n      <For each={rest.options}>\n        {(option, i) => (\n          <Checkbox\n            id={`${store.id}-${i()}`}\n            label={option.label}\n            value={option.value}\n            name={rest.name}\n            onChange={onChange}\n            onBlur={onBlur}\n            error={store.error}\n            checked={checked(option.value)}\n          />\n        )}\n      </For>\n      {rest.helperText && <FormHelperText>{rest.helperText}</FormHelperText>}\n      {store.error && (\n        <FormHelperText error={store.error}>\n          {store.errorMessage}\n        </FormHelperText>\n      )}\n    </FormGroup>\n  );\n};\n";

export { index as default };
